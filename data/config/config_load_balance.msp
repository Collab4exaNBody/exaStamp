
########################### Load balancing ############################
# trigger load balance whenever domain size changed, whatever freq has been requested
# extend_domain has an input named enable_domain_extension to control if domain extesion is allowed
# enable_domain_extension is defined as false in 'global'
trigger_load_balance:
  - trigger_lb_tmp:
      condition: enable_load_balance
      rebind: { result: trigger_lb_tmp , freq: simulation_load_balance_frequency }
      body:
        - nth_timestep: { first: false , delayed: true }
  - extend_domain
  - combine:
      rebind: { in1: trigger_lb_tmp , in2: domain_extended , result: trigger_load_balance }
      body: [ boolean_or ]

# define cost model to use
load_balance_cost_model: simple_cost_model

# automatic fitting of cost model parameters
cost_model_fitting_prolog:
  - trigger_cost_model_fitting:
      condition: enable_load_balance
      rebind: { result: trigger_cost_model_fitting , freq: simulation_load_balance_frequency }
      body:
        - nth_timestep: { first: false , delayed: true }
  - do_cost_model_fitting_prolog:
      condition: trigger_cost_model_fitting
      rebind: { rcut: nbh_dist_lab }
      body:
        - start_grid_cell_profiling # starting profiling befor prefetchng also prefetch cell profiling data array
        - zero_compute_force: { type: ignore } # data prefetching for more accurate measure
        - start_grid_cell_profiling # prepare for real profiling during compute_force block

cost_model_fitting_epilog:
  condition: trigger_cost_model_fitting
  body:
    - cost_model_fit: { order: 2 , samples: 256 }

# define how load balancing is done
load_balance:
  - load_balance_cost_model
  - load_balance_rcb
#  - cpu_gpu_load_balance

load_balancing_if_triggered:
  condition: trigger_load_balance
  body:
    - load_balance
#######################################################################

